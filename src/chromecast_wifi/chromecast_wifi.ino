#include <ArduinoWebsockets.h>
#include "esp_http_server.h"
#include <WiFi.h>
//#include <Preferences.h>
#include "BluetoothSerial.h"

String ssids_array[25];
String network_string;
String connected_string;

#define main_html_len 4316
const uint8_t main_html[] = {
0x1f,0x8b,0x08,0x08,0x49,0xa1,0x00,0x5e,0x00,0xff,0x69,0x6e,0x64,0x65,0x78,0x2e,0x68,0x74,0x6d,0x6c,0x2e,0x67,0x7a,0x00,0x55,0x52,0x5f,0x6b,0xdb,0x30,0x10,0x7f,0x8e,0x3f,0xc5,0x21,0x18,0x4e,0xe9,0x22,0xa7,0xdd,0xcb,0x48,0x6c,0xc3,0x5a,0xfa,0x30,0xd8,0xd8,0x58,0x18,0x7d,0x1c,0xb2,0x74,0x8d,0x6f,0xb3,0xa5,0x22,0x9d,0x63,0xc2,0xc8,0x77,0xef,0x39,0xff,0xc6,0xfc,0x72,0xd2,0xdd,0xef,0xcf,0xdd,0xc9,0x65,0xcb,0x7d,0x57,0x67,0x65,0x8b,0xc6,0x49,0xe8,0x91,0x0d,0x78,0xd3,0x63,0x95,0xef,0x08,0xc7,0xd7,0x10,0x39,0x87,0xcb,0x67,0x83,0x67,0xf4,0x5c,0xe5,0x23,0x39,0x6e,0x2b,0x87,0x3b,0xb2,0xb8,0x38,0x5e,0xde,0x5f,0x41,0xe4,0x89,0xc9,0x74,0x8b,0x64,0x4d,0x87,0xd5,0x9d,0x5e,0xfe,0x2b,0x0d,0x09,0xe3,0x31,0x6f,0x1a,0x29,0xf9,0x90,0x43,0x21,0x96,0x4c,0xdc,0x61,0xfd,0xb4,0xf9,0xfe,0xe1,0x7e,0xf1,0xf8,0xe9,0x6b,0x59,0x9c,0x12,0x59,0x59,0x9c,0x7b,0x6a,0x82,0xdb,0x4b,0x70,0xb4,0x03,0x72,0x55,0x1e,0x06,0xc6,0xf8,0x28,0xad,0x18,0xf2,0x18,0xf3,0x3a,0x83,0x92,0xfa,0xed,0x54,0x52,0x89,0x23,0x9a,0x5e,0x41,0x8a,0xb6,0x52,0x12,0x78,0x2f,0x3e,0xea,0xd8,0xe0,0xca,0x0c,0x1c,0xd6,0xd0,0x22,0x6d,0x5b,0x5e,0xdd,0x2d,0x97,0xef,0xd4,0x64,0x21,0xa2,0x12,0x92,0x8d,0xf4,0xca,0x75,0x26,0x03,0x26,0x86,0x69,0x70,0xa8,0xc0,0x05,0x3b,0xf4,0x32,0xae,0xde,0x22,0x3f,0x75,0x38,0x1d,0x1f,0xf6,0x9f,0xdd,0x3c,0x3f,0xb9,0xe4,0x37,0xeb,0x33,0xfe,0x79,0xf3,0xeb,0xe7,0x8f,0x2f,0xc2,0x50,0x63,0x5a,0x15,0x85,0x82,0x5b,0x18,0xc9,0xbb,0x30,0xea,0x2e,0x58,0xc3,0x14,0xbc,0x6e,0x83,0xe0,0x6e,0x41,0xad,0x3e,0xde,0xab,0x0b,0x6d,0x4c,0x42,0xf1,0x62,0xf5,0x8c,0xcd,0x26,0xd8,0x3f,0xc8,0xf3,0x93,0x92,0x08,0xcf,0x66,0xd9,0x98,0x74,0xf0,0x3d,0xa6,0x64,0xb6,0x28,0xc0,0xeb,0xa9,0x86,0xbf,0xd9,0x8c,0x5e,0x60,0x7e,0xce,0x68,0x67,0xe4,0xc9,0x48,0x14,0x8d,0xb7,0x18,0x5e,0xe0,0xa1,0x0b,0xcd,0xcd,0x04,0x02,0xd8,0x99,0x08,0x43,0xec,0xbe,0x35,0xbf,0xd1,0xb2,0x88,0x88,0xb8,0xb6,0xd2,0x3c,0xe3,0x29,0x25,0xf7,0xff,0x64,0x26,0x67,0x61,0xc9,0xfc,0x5a,0x56,0x28,0x84,0x2b,0x59,0x0a,0x87,0xec,0xb0,0x96,0x8d,0x5d,0x76,0x55,0x16,0xe7,0x77,0x29,0x8e,0x7f,0xd0,0x1b,0x43,0x52,0xe5,0x80,0x48,0x02,0x00,0x00
};

const char* pref_ssid = "";
const char* pref_pass = "";
String client_wifi_ssid;
String client_wifi_password;

const char* bluetooth_name = "robot01";

long start_wifi_millis;
long wifi_timeout = 10000;
bool bluetooth_disconnect = false;

enum wifi_setup_stages { NONE, SCAN_START, SCAN_COMPLETE, SSID_ENTERED, WAIT_PASS, PASS_ENTERED, WAIT_CONNECT, LOGIN_FAILED };
enum wifi_setup_stages wifi_stage = NONE;

using namespace websockets;
WebsocketsServer socket_server;
BluetoothSerial SerialBT;
//Preferences preferences;

void setup()
{
  Serial.begin(115200);
  Serial.println("Booting...");

//  preferences.begin("wifi_access", false);

  if (!init_wifi()) { // Connect to Wi-Fi fails
    SerialBT.register_callback(callback);
  } else {
    SerialBT.register_callback(callback_show_ip);
  }

  SerialBT.begin(bluetooth_name);
  socket_server.listen(82);
}

bool init_wifi()
{
//  String temp_pref_ssid = preferences.getString("pref_ssid");
//  String temp_pref_pass = preferences.getString("pref_pass");
  String pref_ssid = temp_pref_ssid.c_str();
  String pref_pass = temp_pref_pass.c_str();

  Serial.println(pref_ssid);
  Serial.println(pref_pass);

  WiFi.config(INADDR_NONE, INADDR_NONE, INADDR_NONE);

  start_wifi_millis = millis();
  WiFi.begin(pref_ssid, pref_pass);
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
    if (millis() - start_wifi_millis > wifi_timeout) {
      WiFi.disconnect(true, true);
      return false;
    }
  }
  return true;
}

void scan_wifi_networks()
{
  WiFi.mode(WIFI_STA);
  // WiFi.scanNetworks will return the number of networks found
  int n =  WiFi.scanNetworks();
  if (n == 0) {
    SerialBT.println("no networks found");
  } else {
    SerialBT.println();
    SerialBT.print(n);
    SerialBT.println(" networks found");
    delay(1000);
    for (int i = 0; i < n; ++i) {
      ssids_array[i + 1] = WiFi.SSID(i);
      Serial.print(i + 1);
      Serial.print(": ");
      Serial.println(ssids_array[i + 1]);
      network_string = i + 1;
      network_string = network_string + ": " + WiFi.SSID(i) + " (Strength:" + WiFi.RSSI(i) + ")";
      SerialBT.println(network_string);
    }
    wifi_stage = SCAN_COMPLETE;
  }
}

void callback(esp_spp_cb_event_t event, esp_spp_cb_param_t *param)
{
  
  if (event == ESP_SPP_SRV_OPEN_EVT) {
    wifi_stage = SCAN_START;
  }

  if (event == ESP_SPP_DATA_IND_EVT && wifi_stage == SCAN_COMPLETE) { // data from phone is SSID
    int client_wifi_ssid_id = SerialBT.readString().toInt();
    client_wifi_ssid = ssids_array[client_wifi_ssid_id];
    wifi_stage = SSID_ENTERED;
  }

  if (event == ESP_SPP_DATA_IND_EVT && wifi_stage == WAIT_PASS) { // data from phone is password
    client_wifi_password = SerialBT.readString();
    client_wifi_password.trim();
    wifi_stage = PASS_ENTERED;
  }
}

void callback_show_ip(esp_spp_cb_event_t event, esp_spp_cb_param_t *param)
{
  if (event == ESP_SPP_SRV_OPEN_EVT) {
    SerialBT.print("ESP32 IP: ");
    SerialBT.println(WiFi.localIP());
    bluetooth_disconnect = true;
  }
}

static esp_err_t main_handler(httpd_req_t *req) {
  httpd_resp_set_type(req, "text/html");
  httpd_resp_set_hdr(req, "Content-Encoding", "gzip");
  return httpd_resp_send(req, (const char *)main_html, main_html_len);
}

httpd_uri_t main_uri = {
  .uri       = "/",
  .method    = HTTP_GET,
  .handler   = main_handler,
  .user_ctx  = NULL
};

void disconnect_bluetooth()
{
  delay(1000);
  Serial.println("BT stopping");
  SerialBT.println("Bluetooth disconnecting...");
  delay(1000);
  SerialBT.flush();
  SerialBT.disconnect();
  SerialBT.end();
  //Serial.println("BT stopped");
  delay(1000);
  bluetooth_disconnect = false;
}

void loop()
{
  if (bluetooth_disconnect)
  {
    disconnect_bluetooth();
  }

  switch (wifi_stage)
  {
    case SCAN_START:
      SerialBT.println("Scanning Wi-Fi networks");
      Serial.println("Scanning Wi-Fi networks");
      scan_wifi_networks();
      SerialBT.println("Please enter the number for your Wi-Fi");
      wifi_stage = SCAN_COMPLETE;
      break;

    case SSID_ENTERED:
      SerialBT.println("Please enter your Wi-Fi password");
      Serial.println("Please enter your Wi-Fi password");
      wifi_stage = WAIT_PASS;
      break;

    case PASS_ENTERED:
      SerialBT.println("Please wait for Wi-Fi connection...");
      Serial.println("Please wait for Wi_Fi connection...");
      wifi_stage = WAIT_CONNECT;
//      preferences.putString("pref_ssid", client_wifi_ssid);
//      preferences.putString("pref_pass", client_wifi_password);
      if (init_wifi()) { // Connected to WiFi
        connected_string = "ESP32 IP: ";
        connected_string = connected_string + WiFi.localIP().toString();
        SerialBT.println(connected_string);
        Serial.println(connected_string);
        bluetooth_disconnect = true;
      } else { // try again
        wifi_stage = LOGIN_FAILED;
      }
      break;

    case LOGIN_FAILED:
      SerialBT.println("Wi-Fi connection failed");
      Serial.println("Wi-Fi connection failed");
      delay(2000);
      wifi_stage = SCAN_START;
      break;
  }

  if (socket_server.poll()) {
    disconnect_bluetooth();
    auto client = socket_server.accept();
    while (client.available()) {
    }
  }
  
}
